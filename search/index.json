[{"content":"The problem As a developer, you likely run a lot of code you can’t or don’t have time to verify. Many modern projects have lots of dependencies, and none of the package managers I know provide any isolation from the rest of your system. For example, create-react-app will install 1400 dependencies from 285 authors. Do you trust all of them? More importantly, do you trust their security posture?\nEventually, this will go wrong. Many examples exist (PyPI, NPM, AUR). Even though the lack of isolation is the de facto standard, I think this is borderline irresponsible. Especially as a freelance developer working for multiple clients. Therefore, while I can’t fully prevent supply-chain attacks, I can drastically minimize their potential damage.\nIn practice, this means I need a system to isolate projects from each other and from the system itself. However, it needs be easy to use, performant, and above all it needs to get out of my way while I\u0026rsquo;m working. I wrote a tool named probox, and after using it for a few months, I think I reached my goal.\nThis how the end result will look like, but read on for the details:\nHow to isolate Let’s get this out of the way first: if you’re looking for the strongest possible isolation, you need to use emulation (e.g. Qubes OS). For my purposes, that seemed like too high a price in convenience and performance.\nSo I went with containers. After using docker in many projects before, I settled on using podman as it was more performant, has a stronger focus on security (e.g. rootless mode) and integrates better with Linux (e.g. systemd support).\nIn order to protect my projects from eachother and the host, I create a container per project. Exactly what constitutes one project is up to you.\nStateful over stateless Unlike most usages of containers, you want these “development” containers to not be disposable by default. Since you can’t foresee every tool or config you’ll ever need for development, your Containerfile will never be finished. So you’ll either spend an ungodly amount of time rebuilding your base image, or you’ll have to be very disciplined about using podman commit, or you’ll just lose all your progress upon every reboot. Best to just keep your containers stateful—this is the default anyway.\nBeefy containers While stateful containers are assumed, it also shouldn\u0026rsquo;t be too hard to (re)create containers. The more you include in your base image, the less work you\u0026rsquo;ll have to do after creating a new container. OTOH, more software means a larger attack surface.\nEventually I settled on a pretty beefy base image with most of the tools I use during development already installed. This includes a fancy shell, compilers, debuggers, runtimes, language servers, an IDE with plenty of plugins, etc. I only pay the storage cost once, as the image is shared among all my containers.\nYou can find the base image I use on github, but you should probably modify it before you use it. It is based on Arch Linux, with tools for Python, Javascript, Rust and C/C++. I also include code-server (a hosted variant of VSCode) and configuration for Podman-In-Podman.\nWhat to share In order to make the experience as convenient as possible, I try to maintain the illusion that you’re working on one single Linux system. That is, as long as you stay within the project-based boundaries, the experience is equivalent to not using containers at all.\nFiles Every development container is linked to a single directory in my filesystem. To maintain the illusion, it is bound on the exact same path as on my host filesystem. The container also uses the same UID so there are no permission conflicts. (In podman terms, --userns=keep-id).\nNetwork For my type of development, I use a lot of services that expose HTTP ports and expect you to use a browser. I still run my browser in the host (see below). Again we have to maintain the illusion, so if vite tells me it is running on port 5173, I want to be able to go to 127.0.0.1:5173 without issues. I definitely don’t want to recreate the entire container with a different --expose option as podman would have you do by default.\nLuckily, podman uses pasta under the hood which can automatically forward ports from container to host. Importantly you can also make it not forward ports from host to container. So I use the flag --network=pasta:-t,auto,-u,auto,-T,none,-U,none and everything Just Works.\nExcept for one thing: pasta will forward ports from container to host if they’re bound on 0.0.0.0, and will also bind the forwarded port on 0.0.0.0 on the host. This means I still need to use a firewall on my host to limit the ports that are available to the rest of my network. While I’d love a solution that doesn’t rely on a firewall, I think this is a good tradeoff. Sometimes I do want to share a port with my smartphone to test something, and I also think ports bound on localhost in a container should remain within the container. Luckily firewall configuration is pretty easy with firewall-config which came preinstalled on my Fedora host.\nSSH keys This is where things get really interesting. I don’t think I can claim much security benefits if I don’t protect my SSH keys. I can’t just allow any container read access to the keys themselves. This is why I start an ssh-agent in the host, per project, and forward the agent to the container. Then, combined with ksshaskpass (or an equivalent program), I can manage which containers can access which key and even interactively allow or deny the usage of a key (with ssh-add -c).\nProbox I automated all the things above in a tool I call probox. Check it out on GitHub!\nIt is a single Python file without dependencies so it should be easy to install (and verify). It still needs some work (the default image will only work for me) but feel free to reach out to me if you are interested in it.\n90% of my usage consists of just two commands: probox create and probox run. Probox automatically uses the current directory and tries to match it to a project. But there are more commands:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 usage: probox [-h] {create,run,temp,stop,ssh-add,name,ls,overlay,ports} ... Manage containers for your development projects (with podman). positional arguments: create Create a new container (box) for your project run Run an existing container (start and exec) temp Create and run a temporary container stop Stop a container ssh-add Add key to ssh-agent for project (tip: use -c to confirm usage in host) name Get name of container attached to directory ls List all probox containers overlay Manage overlay files (useful for configs/dotfiles/...) ports List all exposed ports I should also mention similar tools like distrobox or toolbx. The major difference is that they do not strive towards any kind of security guarantees. They mount the entire home directory by default. For example, consider this toolbx issue or this distrobox issue.\nConclusion: is this safe? I hope so! But I’d love to hear what others have to say about it. I read this discussion but can’t seem to find a better solution than what I have now. probox create will use these flags:\n1 2 3 4 5 6 7 8 --userns=keep-id --security-opt label=disable # required for mounting the volume --pids-limit=-1 --cap-add=NET_RAW # required for ping --device=/dev/fuse # required for PINP --volume ~/projects/foo:/home/evert/projects/foo --volume ~/foo-ssh-agent:/home/evert/ssh-agent.socket --network=pasta:-t,auto,-u,auto,-T,none,-U,none Feel free to discuss this article on Hackernews or r/podman. Alternatively, open an issue on github or send me an email.\nBonus: the rest of my system If you are interested in probox, you might also be interested how I protect/isolate other parts of my system. Here’s a quick rundown.\nHost OS: Fedora Kinoite. As I do everything in containers anyway, I liked the (minor) benefit of an atomic OS. I run most of my GUI apps in Flatpak (Kate, Spotify, KeePassXC, …). I care less about the “portability” aspect of Flatpak and strongly prefer flatpaks from the Fedora repository over Flathub. I will usually check the permissions given to a flatpak and restrict them if necessary. None of the apps can read my files unrestricted, instead I rely heavily on portals. I mainly use Firefox (also in a Flatpak), combined with Chromium for PWA’s like code-server. On top of that I also installed Mullvad browser where I disabled JIT and other fancy features for untrusted websites. ","date":"2025-02-15T00:00:00Z","image":"https://evertheylen.eu/p/probox-intro/seal_center2_hu_c3bd628c167dfa2b.jpg","permalink":"https://evertheylen.eu/p/probox-intro/","title":"Everyday project isolation for developers on Linux"},{"content":"In this article I\u0026rsquo;ll be comparing the performance of Bun vs Node. In particular (as Bun is many things), I will focus on their performance as the runtime for your server-side JavaScript code. With Node being the default choice for many, Bun has to prove it is worthy of your attention. It makes strong claims:\nThere’s a benchmark right on the homepage, claiming almost 5 times more requests per second than Node! 1. In the documentation, they claim that “In most cases, the startup and running performance is faster than V8, the engine used by Node.js and Chromium-based browsers.” Part of what makes this an interesting comparison is that Node uses the V8 engine (which also powers Chromium-based browsers), while Bun uses JavascriptCore (which powers Safari).\nBenchmark setup I will be running the benchmarks from this excellent GitHub project: github.com/nDmitry/web-benchmarks. The README says:\n[…] on each request it simply fetches a 100 fake users from the [Postgres] database, creates a class instance/structure for each row converting a datetime object to an ISO string and encrypting one of the fields with Caesar cypher, serializes resulting array to JSON and responds with this payload.\nI think it’s a reasonable setup for benchmarks like this. The repository also has instructions for running Python and Go benchmarks, if you’re interested in that. (Spoiler: Go is about 2x faster than Node, and Node is maybe 10% faster than async CPython on a good day.)\nI adjusted a few things which you can find in my fork. Each benchmark will run with a fixed amount of processes (eg. node-8 will be using 8 processes). I\u0026rsquo;m using hey to do 50000 requests. All benchmarks run on an AMD 5900X processor (12 physical cores, 24 threads) with 32GB of memory.\nSoftware versions - OS: Arch Linux, kernel 6.9.7-arch1-1 - Node: v22.9.0 - Bun: 1.0.28 - hey: 0.1.4-6 Results In short: Node has a very slight performance advantage, but it is almost negligible.\nResults for 100 parallel connections I tried many variations of the test, to see if I could find a scenario where the differences would be larger. In particular, I tested different amounts of parallel connections. The chart above is for 100 connections in parallel (hey -c 100), but the same pattern holds for 200, 800, even up to 2000 connections. At such high connection counts, RPS actually drops for both.\nRunning without Postgres A rather drastic thing you could do is remove the Postgres connection from the benchmark. I did this by hardcoding the result you’d usually get from Postgres. This makes it almost a “hello world” benchmark, but it still has the Caesar cipher and some JSON.stringify going on. The result:\nResults for 200 parallel connections, without Postgres Here, Bun clearly takes the win. In fact, I tried the Go server and it hits (only) about 100k RPS. Bun beats Go! However, I’d argue this is almost meaningless. If your server is this simple, run it in the client.\nDiscussion It\u0026rsquo;s a boring result, but an expected one: in real-world usecases, your servers will likely not get any performance boost out of Bun. Bun\u0026rsquo;s extraordinary claims only hold up for hello-world-style benchmarks.\nMultiprocessing differences To run a Node server with multiple processes, I used the cluster package, but this is not implemented yet in Bun. Instead I have to spawn different Bun processes that should each run serve({reusePort: true, ...}), as described by the excellent Bun guides.\nThe end result works similarly to Node’s cluster module, but Node’s solution is a lot nicer to use. It’s easier to check for cluster.isPrimary and use cluster.fork() than to maintain multiple entrypoints. Node also claims “some built-in smarts to avoid overloading a worker process”, which Bun may lack. On the other hand, inter-process communication seems easy on both platforms should you need it.\nImpact of frameworks I chose not to use any server frameworks/libraries to focus on the runtime itself. The original repository did test a few popular Node frameworks, which shows a sizable performance impact. From fast to slow, it goes koa \u0026gt; express \u0026gt; hapi. In any case, not using a framework is always the fastest.\nIn my own (separate) tests, using a library like hapi did make Node substantially slower than Bun. Bun’s native serve API feels more modern and functional, so maybe you won\u0026rsquo;t need a framework at all. If you have to choose between Node+hapi and just Bun, Bun will win. But as a more realistic example, Node+koa vs Bun+Hono is (probably) going to be quite close.\nStartup time Bun also claims a much faster startup time. I have no reason to doubt that:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ hyperfine\\ \u0026#34;node -e \u0026#39;require(\\\u0026#34;http\\\u0026#34;).createServer(() =\u0026gt; {}).listen(8000).close()\u0026#39;\u0026#34;\\ \u0026#34;bun -e \u0026#39;(await import(\\\u0026#34;bun\\\u0026#34;)).serve({fetch: () =\u0026gt; {}, port: 8000, development: false}).stop()\u0026#39;\u0026#34; Benchmark 1: node -e \u0026#39;require(\u0026#34;http\u0026#34;).createServer(() =\u0026gt; {}).listen(8000).close()\u0026#39; Time (mean ± σ): 18.6 ms ± 1.7 ms [User: 12.7 ms, System: 6.1 ms] Range (min … max): 17.4 ms … 29.8 ms 142 runs Benchmark 2: bun -e \u0026#39;(await import(\u0026#34;bun\u0026#34;)).serve({fetch: () =\u0026gt; {}, port: 8000, development: false}).stop()\u0026#39; Time (mean ± σ): 11.7 ms ± 0.5 ms [User: 4.3 ms, System: 9.5 ms] Range (min … max): 11.1 ms … 14.5 ms 253 runs Summary bun -e \u0026#39;(await import(\u0026#34;bun\u0026#34;)).serve({fetch: () =\u0026gt; {}, port: 8000, development: false}).stop()\u0026#39; ran 1.59 ± 0.15 times faster than node -e \u0026#39;require(\u0026#34;http\u0026#34;).createServer(() =\u0026gt; {}).listen(8000).close()\u0026#39; The extra 7ms is nice for tooling, but for servers I honestly don’t think it matters much.\nWhere is Deno? I like that Deno tries something new with an interesting permission system. But from a performance perspective, they use V8 just like Node, so I thought it was less interesting. Feel free to send a PR with a Deno server and I’ll include the results.\nI believe there is a chance Bun is kinda cheating here, with a different version of React than what Node uses. See this benchmark.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-10-04T00:00:00Z","image":"https://evertheylen.eu/p/node-vs-bun/cover2_hu_97a7e368ad2dc91.webp","permalink":"https://evertheylen.eu/p/node-vs-bun/","title":"Node vs Bun: no backend performance difference"},{"content":"The problem My requirements are as follows:\nMy main development environment has to be Linux. (Not just WSL, I want a proper Linux desktop environment.) I like to sketch stuff and draw diagrams. Paper works, but it gets disorganized really quickly. A digital device allows me to keep my notes organized and you can have an infinite canvas with nice colors and edit history. (Note: I don’t think there are good apps like this on Linux.) I want to build my own desktop. You can get a lot more performance for your money, and I can hand-pick each component to my liking (e.g. a good CPU, a mid-tier GPU, stellar Linux support). While I spend most of my time working from home, I do have to work in other places sometimes. I don’t want to maintain duplicate environments. Requirement 2 suggests a tablet, 3 suggests a desktop, and 4 suggests a laptop. A windows laptop-tablet hybrid may be a compromise solution but I tried it and did not like it 1.\nThe solution I have two devices:\nA desktop I built myself, which runs Linux. A Samsung Tab S7+, on which I run OneNote. This setup satisfies requirements 1, 2 and 3. But how do I satisfy requirement 4? It’s a combination of three things:\ncode-server, which lets you run Visual Studio Code in any browser. DeX mode on the Samsung tablet, although not technically required, gives me a traditional desktop environment. I also have the keyboard accessory. A bunch of networking configuration so I can reach my desktop from the internet. I only expose a single SSH port, and use SSH tunnels for anything else. (I use duckdns and JuiceSSH Pro to make it work). This allows me to remotely connect with code-server (running on my desktop) through an SSH tunnel. In the end I’m able to work using the exact same editor as if I were on my desktop. This isn’t rocket science of course, it’s kinda like a home-built version of Github Codespaces where the server lives in your house.\nThis is fine for “simple” development where you never leave your IDE or terminal. Web development is a little harder because you really want to debug your frontend using devtools. While forwarding the ports to vite (or whatever you want to use) is no problem, most browsers on Android assume you do all your debugging work remotely via USB or the network. The solution is Kiwi Browser, which has full devtools available.\nConclusion I’ve been using this setup for more than 2 years now and I really like it. It’s not for everyone as it requires a little work to set up and maintain, but for me it combines the best of Android with the best of (Desktop) Linux leading to a very smooth experience.\nIf you have any questions about this setup, feel free to contact me!\nI once had an HP ZBook Studio G5, which seemed like a powerful laptop with a nice large pen-supported touchscreen. One problem, Linux support was really sketchy. I really tried to make it work, even manually compiling chromium to include Wayland support. Even then I couldn’t find a good note-taking app. So I settled on Windows with WSL but just plain didn’t like it. Then one day I opened my laptop to a big advert for some XBox service and that settled it \u0026ndash; no more Windows.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-02-11T00:00:00Z","image":"https://evertheylen.eu/p/my-desktop-tablet-development-setup/tablet_with_desktop_hu_a0b7b2221ebb7f28.jpg","permalink":"https://evertheylen.eu/p/my-desktop-tablet-development-setup/","title":"My Desktop+Tablet Development Setup"}]